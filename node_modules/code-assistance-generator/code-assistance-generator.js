const gulp = require(`gulp`);
const Vinyl = require(`vinyl`);
const execSync = require(`child_process`).execSync;

const stringSrc = (filename, string) => {
  var src = require(`stream`).Readable({
    objectMode: true
  });
  src._read = function () {
    this.push(new Vinyl({
      path: filename,
      contents: new Buffer(string)
    }));
    this.push(null);
  };
  return src;
};
const addAssistance = (currentMap, jsdocEntry, completionTemplate) => {
  let memberofParts;
  const memberof = jsdocEntry.memberof;
  if (!memberof) {
    memberofParts = [];
  } else {
    memberofParts = memberof.split(`.`);
  }
  for (let i = 0; i < memberofParts.length; i++) {
    let memberofPart = memberofParts[i];
    let definition = currentMap.get(memberofPart);
    if (!definition) {
      definition = {
        description: memberofPart,
        name: memberofPart,
        image: `dijitIcon dijitTreeIcon bindingSelectorTree_Item bindingSelectorTree_Item_VariablePrivate`,
        title: memberofPart,
        children: new Map()
      };
      currentMap.set(memberofPart, definition);
    }
    currentMap = definition.children;
  }
  let addDefiniton = currentMap.get(jsdocEntry.name) || {
    children: new Map()
  };

  let description = jsdocEntry.name;
  let title = jsdocEntry.description;
  let name = jsdocEntry.name;
  if (jsdocEntry.kind === `function`) {
    description += `(`;
    name += `(`;
    let descriptions = [];
    let richDescriptions = [];
    let names = [];
    title += `<br>`;
    if (jsdocEntry.params) {
      jsdocEntry.params.forEach((param) => {
        let paramTypes = ``;
        if (param.type) {
          if (param.type.names) {
            paramTypes = param.type.names.join(`|`);
          }
        }
        let paramName = param.name;
        let paramDesription = param.description;
        descriptions.push(`${paramTypes? paramTypes + ` ` : paramTypes}${paramName}`);
        richDescriptions.push(`@param {${paramTypes}} ${paramName}${paramDesription? ` - ` + paramDesription:``}<br>`);
        names.push(paramName);
      });
    }
    let allParamTypes = [];
    let allDescriptions = [];
    if (jsdocEntry.returns) {
      jsdocEntry.returns.forEach((returnType) => {
        if (returnType.type) {
          if (returnType.type.names) {
            allParamTypes.push(returnType.type.names.join(`|`));
          }
        }
        let desription = returnType.description;
        allDescriptions.push(desription);
      });
    }
    description += descriptions.join(`, `);
    description += `)`;
    title += richDescriptions.join(``);
    if (allParamTypes.length > 0) {
      description += ` - ${allParamTypes.join(`|`)}`;
      for (let i = 0; i < allParamTypes.length; i++) {
        title += `@returns {${allParamTypes[i]}}${allDescriptions[i]?` - ` + allDescriptions[i]:``}<br>`;
      }
    }
    name += names.join(`, `);
    name += `)`;
  }
  if (completionTemplate) {
    name = completionTemplate;
  }

  addDefiniton.description = description;
  addDefiniton.name = name;
  addDefiniton.image = `dijitIcon dijitTreeIcon bindingSelectorTree_Item bindingSelectorTree_Item_VariablePrivate`;
  addDefiniton.title = title;
  currentMap.set(jsdocEntry.name, addDefiniton);
};
const constructAssistance = (currentMap) => {
  const assistance = [];
  if (currentMap && currentMap.size) {
    const iterator = currentMap.entries();
    let result = iterator.next();
    while (!result.done) {
      let definition = result.value[1];
      let assistanceEntry = {
        description: definition.description,
        name: definition.name,
        image: definition.image,
        title: definition.title,
        children: constructAssistance(definition.children)
      };
      assistance.push(assistanceEntry);
      result = iterator.next();
    }
  }
  return assistance;
};
const generateAssistance = (jsdocConfPath, destinationPath) => {
  const binPath = execSync(`npm bin`).toString().trim();
  const json = execSync(`${binPath}\\jsdoc . -r -c ${jsdocConfPath} -X `).toString();
  const jsdoc = JSON.parse(json);
  const inlinejsAssistanceMap = new Map();
  const serverjsAssistanceMap = new Map();
  jsdoc.forEach((jsdocEntry) => {
    let tags = jsdocEntry.tags;
    let inlinejsAssistancePresent = false;
    let serverjsAssistancePresent = false;
    let completionTemplate;
    if (tags) {
      tags.forEach((tag) => {
        if (tag.title === `inlinejsassistance`) {
          inlinejsAssistancePresent = true;
        } else if (tag.title === `serverjsassistance`) {
          serverjsAssistancePresent = true;
        } else if (tag.title === `completiontemplate`) {
          completionTemplate = tag.text;
        }
      });
    }
    if (inlinejsAssistancePresent) {
      addAssistance(inlinejsAssistanceMap, jsdocEntry, completionTemplate);
    }
    if (serverjsAssistancePresent) {
      addAssistance(serverjsAssistanceMap, jsdocEntry, completionTemplate);
    }
  });
  stringSrc(`assistance/inlinejs-assistance.json`, JSON.stringify(constructAssistance(inlinejsAssistanceMap)))
    .pipe(gulp.dest(destinationPath));
  stringSrc(`assistance/serverjs-assistance.json`, JSON.stringify(constructAssistance(serverjsAssistanceMap)))
    .pipe(gulp.dest(destinationPath));
};

module.exports = generateAssistance;
